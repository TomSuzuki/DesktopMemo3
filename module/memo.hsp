
// メモ設定
#const global MinMemoWidth 320
#const global MinMemoHeight 240

// メモ管理モジュール
#module MOD_MEMO jsonText, path, text, x, y, w, h, wid, colorId, btnId_Add, btnId_Col, btnId_Pin, btnId_Del, isPin, textAreaId
#define LEFT		0x00000001
#define RIGHT		0x00000002
#define TOP			0x00000004
#define BOTTOM		0x00000008
#define CaptionHeight ButtonSize
#define BORDERWIDTH 4
// コンストラクタ（infoはjson文字列）
#modinit str _jsonText
    jsonText = _jsonText

    // JSON形式を開く
    jsonopen@ jsonPtr, jsonText

    // 読み込み
    jsongets@ path, "path", jsonPtr
    jsongeti@ x, "x", jsonPtr
    jsongeti@ y, "y", jsonPtr
    jsongeti@ w, "w", jsonPtr
    jsongeti@ h, "h", jsonPtr
    jsongeti@ colorId, "color_id", jsonPtr
    jsongeti@ isPin, "pin", jsonPtr

    // JSONを閉じる
    jsonclose@

    // 読み込み
    notesel text
    noteload path
    noteunsel

    // 不正な値を防ぐ
    if(colorId != limit(colorId, 0, ColorNum))

    // ウィンドウ位置・大きさ修正
    w = limit(w, MinMemoWidth, w)
    h = limit(h, MinMemoHeight, h)

    // ウィンドウ生成
    wid = OverrapBgWin(x, y, w, h, *OnResize, *OnWidthChange)
    gsel wid, 1+isPin
	gosub *OnResize

    return

#modcfunc WidthChange

    // 処理するウィンドウ
    gsel wid

    // 座標
    mposx = ginfo_mx - ginfo_wx1
    mposy = ginfo_my - ginfo_wy1

    // マウスが範囲外なら別ウィンドウ
    // [TODO] 非アクティブ時の幅調節
    if (mposx < -BORDERWIDTH || mposx > ginfo_winx+BORDERWIDTH || mposy < -BORDERWIDTH || mposy > ginfo_winy+BORDERWIDTH) {
        return HTCAPTION
    }

    // マウスのポジション
    dim area
    if (mposx <= BORDERWIDTH)             : area |= LEFT
    if (mposx >= ginfo_winx - BORDERWIDTH): area |= RIGHT
    if (mposy <= BORDERWIDTH)             : area |= TOP
    if (mposy >= ginfo_winy - BORDERWIDTH): area |= BOTTOM

    // 各方向ごとの処理
    if (area & LEFT) {
        if (area & TOP)    : return HTTOPLEFT
        if (area & BOTTOM) : return HTBOTTOMLEFT
        return HTLEFT
    }
    if (area & RIGHT) {
        if (area & TOP)    : return HTTOPRIGHT
        if (area & BOTTOM) : return HTBOTTOMRIGHT
        return HTRIGHT
    }
    if (area & TOP)    : return HTTOP
    if (area & BOTTOM) : return HTBOTTOM

    // マウス座標がタイトルバーなら移動
    if (mposy <= CaptionHeight) : return HTCAPTION

    return 0

// 再描画
#modfunc Resize

    // 処理するウィンドウ
    gsel wid
    redraw 0

    // 最小幅 [TODO] 画面がちらつく
    if(MinMemoWidth > ginfo_winx):width MinMemoWidth, ginfo_winy
    if(MinMemoHeight > ginfo_winy):width ginfo_winx, MinMemoHeight

    // 背景色
	color decRGB(getColor(colorId, ColorTypeTheme))
	boxf

    // ボタンの初期化
    if(btnId_Add != 0):clrobj btnId_Add, btnId_Add
    if(btnId_Col != 0):clrobj btnId_Col, btnId_Col
    if(btnId_Pin != 0):clrobj btnId_Pin, btnId_Pin
    if(btnId_Del != 0):clrobj btnId_Del, btnId_Del

    // ボタンの配置
    CreateButtonImage ButtonTypeAdd, colorId :pos ButtonSize*0,0 :button gosub "",*OnNewWindow@  :btnId_Add = stat
    CreateButtonImage ButtonTypeCol, colorId :pos ButtonSize*1,0 :button gosub "",*OnNewWindow@  :btnId_Col = stat
    CreateButtonImage ButtonTypePinT+1-isPin, colorId :pos ButtonSize*2,0 :button gosub "",*OnButtonPin  :btnId_Pin = stat
    CreateButtonImage ButtonTypeDel, colorId :pos ginfo_winx-ButtonSize,0 :button gosub "",*OnNewWindow@  :btnId_Del = stat

    // テキストエリアの配置
    padding = 5
    if(textAreaId == 0){
        // [TODO] テキストエリアの文字設定
        pos padding, ButtonSize+padding
        mesbox text, ginfo_winx-padding*2, ginfo_winy-padding*2-ButtonSize, 1, -1
        textAreaId = stat
    }else{
        size = ginfo_winx-padding*2, ginfo_winy-padding*2-ButtonSize, padding, ButtonSize+padding
        resizeobj textAreaId, size, 0
    }

    // メモの更新
    saveMemo thismod

    redraw 1

    return

// ピン止め処理
#modfunc Pin
    isPin = isPin == false
    Resize thismod
    gsel wid, 1+isPin
    return

// メモの保存
#modfunc saveMemo
    await
    return

// ゲッター
#modcfunc getWid
    return wid

// ---------------------------------------------------------------------
// ピン止めボタンの処理
*OnButtonPin
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // ピン止めの処理
        Pin memo.cnt
        break
    loop
    return

// 画面リサイズ時＋初期化表示
*OnResize
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // リサイズ時の処理
        Resize memo.cnt
        break
    loop
    return

// 画面リサイズ用の動き
*OnWidthChange
    n = HTCAPTION
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // リサイズ用の処理
        n = WidthChange(memo.cnt)
        break
    loop
    return n
#global
