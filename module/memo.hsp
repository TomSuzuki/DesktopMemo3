
// メモ設定
#const global MinMemoWidth 320
#const global MinMemoHeight 240

// メモ管理モジュール
#module MOD_MEMO jsonText, memoPath, path, text, x, y, w, h, wid, colorId, btnId_Add, btnId_Col, btnId_Pin, btnId_Del, isPin, textAreaId, hMesbox, hBrush
#uselib "user32"
    #cfunc GetWindowLong "GetWindowLongA" int, int
    #func SetWindowLong "SetWindowLongA" int, int, int
	#func SetWindowPos "SetWindowPos" int, nullptr, nullptr, nullptr, nullptr, nullptr, int
#uselib "gdi32"
    #func CreateSolidBrush "CreateSolidBrush" sptr
	#func DeleteObject "DeleteObject" sptr
	#func SetBkColor "SetBkColor" sptr,sptr
	#func SetBkMode "SetBkMode" sptr,sptr
	#func SetTextColor "SetTextColor" sptr,sptr
#define ctype BGR(%1,%2,%3) (%1 | %2 << 8 | %3 << 16)
#define GWL_STYLE	$FFFFFFF0
#define GWL_EXSTYLE -20
#define WS_EX_TOOLWINDOW	0x0080
#define LEFT		0x00000001
#define RIGHT		0x00000002
#define TOP			0x00000004
#define BOTTOM		0x00000008
#define CaptionHeight ButtonSize
#define BORDERWIDTH 4
// コンストラクタ（infoはjson文字列）
#modinit str _memoPath, str _jsonText
    memoPath = _memoPath
    jsonText = _jsonText

    // JSON形式を開く
    jsonopen@ jsonPtr, jsonText

    // 読み込み
    jsongets@ path, "path", jsonPtr
    jsongeti@ x, "x", jsonPtr
    jsongeti@ y, "y", jsonPtr
    jsongeti@ w, "w", jsonPtr
    jsongeti@ h, "h", jsonPtr
    jsongeti@ colorId, "color_id", jsonPtr
    jsongeti@ isPin, "pin", jsonPtr

    // JSONを閉じる
    jsonclose@

    // 読み込み
    notesel text
    noteload path
    noteunsel

    // 不正な値を防ぐ
    if(colorId != limit(colorId, 0, ColorNum))

    // ウィンドウ位置・大きさ修正
    w = limit(w, MinMemoWidth, w)
    h = limit(h, MinMemoHeight, h)

    // ウィンドウ生成
    wid = OverrapBgWin(x, y, w, h, *OnResize, *OnWidthChange)// TODO: OnMove
    gsel wid, 1+isPin
	gosub *OnResize

    return

#modcfunc WidthChange

    // 処理するウィンドウ
    gsel wid

    // 座標
    mposx = ginfo_mx - ginfo_wx1
    mposy = ginfo_my - ginfo_wy1

    // マウスが範囲外なら別ウィンドウ
    // TODO: 非アクティブ時の幅調節
    if (mposx < -BORDERWIDTH || mposx > ginfo_winx+BORDERWIDTH || mposy < -BORDERWIDTH || mposy > ginfo_winy+BORDERWIDTH) {
        return HTCAPTION
    }

    // マウスのポジション
    dim area
    if (mposx <= BORDERWIDTH)             : area |= LEFT
    if (mposx >= ginfo_winx - BORDERWIDTH): area |= RIGHT
    if (mposy <= BORDERWIDTH)             : area |= TOP
    if (mposy >= ginfo_winy - BORDERWIDTH): area |= BOTTOM

    // 各方向ごとの処理
    if (area & LEFT) {
        if (area & TOP)    : return HTTOPLEFT
        if (area & BOTTOM) : return HTBOTTOMLEFT
        return HTLEFT
    }
    if (area & RIGHT) {
        if (area & TOP)    : return HTTOPRIGHT
        if (area & BOTTOM) : return HTBOTTOMRIGHT
        return HTRIGHT
    }
    if (area & TOP)    : return HTTOP
    if (area & BOTTOM) : return HTBOTTOM

    // マウス座標がタイトルバーなら移動
    if (mposy <= CaptionHeight) : return HTCAPTION

    return 0

// TODO: 内容更新時のテキスト更新

// TODO: ピン設定変更時の設定更新

// 移動時
#modfunc Move

    // メモの更新
    saveMemo thismod

    return

// 再描画
#modfunc Resize

    // 処理するウィンドウ
    gsel wid
    redraw 0

    // 最小幅 TODO: 画面がちらつく
    if(MinMemoWidth > ginfo_winx):width MinMemoWidth, ginfo_winy
    if(MinMemoHeight > ginfo_winy):width ginfo_winx, MinMemoHeight

    // 背景色
	color decRGB(getColor(colorId, ColorTypeTheme))
	boxf

    // ボタンの初期化
    if(btnId_Add != 0):clrobj btnId_Add, btnId_Add
    if(btnId_Col != 0):clrobj btnId_Col, btnId_Col
    if(btnId_Pin != 0):clrobj btnId_Pin, btnId_Pin
    if(btnId_Del != 0):clrobj btnId_Del, btnId_Del

    // ボタンの配置
    CreateButtonImage ButtonTypeAdd, colorId            :pos ButtonSize*0,0         :button gosub "",*OnButtonNew   :btnId_Add = stat
    ;CreateButtonImage ButtonTypeCol, colorId            :pos ButtonSize*1,0         :button gosub "",*OnNewWindow@  :btnId_Col = stat
    CreateButtonImage ButtonTypePinT+1-isPin, colorId   :pos ButtonSize*2,0         :button gosub "",*OnButtonPin   :btnId_Pin = stat
    CreateButtonImage ButtonTypeDel, colorId            :pos ginfo_winx-ButtonSize,0:button gosub "",*OnButtonDel   :btnId_Del = stat

    // テキストエリアの配置
    padding = 5
    if(textAreaId == 0){
        oncmd gosub *OnCtrlEdit, 0x133
        font fontName, fontSize, fontStyle
        objmode 2,0
        pos padding, ButtonSize+padding
        mesbox text, ginfo_winx-padding*2, ginfo_winy-padding*2-ButtonSize, 1, -1
        textAreaId = stat
        hMesbox = objinfo(stat, 2)
        ShowScrollBar hMesbox, 3, 0
        SetWindowLong hMesbox,-20, 0x0
        SetWindowPos hMesbox, 0x27
        CreateSolidBrush hexBGR(getColor(colorId, ColorTypeBox))
        hBrush = stat
        await
        SetWindowPos hMesbox, 0x27
        sendmsg hMesbox, 0x00B9
        sendmsg hMesbox, 0x00CF, f
    }else{
        size = ginfo_winx-padding*2, ginfo_winy-padding*2-ButtonSize, padding, ButtonSize+padding
        resizeobj textAreaId, size, 0
    }

    // メモの更新
    saveMemo thismod

    redraw 1

    return

// ピン止め処理
#modfunc Pin
    isPin = isPin == false
    Resize thismod
    gsel wid, 1+isPin
    return


// メモの削除
#modfunc DelMemo

    // ファイルの移動
    bcopy memoPath, trashDir + getpath(memoPath, 8)
    delete memoPath

    // ウィドウを非表示
    gsel wid, -1

    // メモリの開放
    DeleteObject hBrush
    buffer wid,1,1,2

    // 削除
    delmod thismod

    return

// テキストエリアの処理
#modcfunc TextArea int _lparam, int _wparam
	if hMesbox = _lparam {
        gsel wid
		SetTextColor _wparam, hexBGR(getColor(colorId, ColorTypeText))
		SetBkColor _wparam, hexBGR(getColor(colorId, ColorTypeBox))
        SetBkMode _wparam, 1
		return hBrush
	}
    return 0

// TODO: メモの保存
#modfunc saveMemo

    // 処理待ち
    await

    // テキストファイルが存在するかチェック
    // TODO: 無ければ内部フォルダの note に新規ファイル → そこに保存

    // 情報の更新
    x = ginfo_wx1
    y = ginfo_wy1
    w = ginfo_sizex
    h = ginfo_sizey

    // 設定データの組み立て
    sdim jsonText
    jsonnewobj@ jsonPtr
    jsonputs@ jsonPtr, "path", path
    jsonputi@ jsonPtr, "x", x
    jsonputi@ jsonPtr, "y", y
    jsonputi@ jsonPtr, "w", w
    jsonputi@ jsonPtr, "h", h
    jsonputi@ jsonPtr, "color_id", colorId
    jsonputi@ jsonPtr, "pin", isPin
    jsonout@ jsonText, jsonPtr
    jsonclose@

    // 設定の保存
    notesel jsonText
    notesave memoPath
    noteunsel

    // テキストの保存

    return

// ゲッター
#modcfunc getWid
    return wid

// ---------------------------------------------------------------------
// テキストエリアの処理
*OnCtrlEdit
    n = 0
    foreach memo
        // テキストエリアの処理
        n = TextArea(memo.cnt, lparam, wparam)
        if(n != 0):break
    loop
    return n

// 新規メモ追加
*OnButtonNew
    createNewMemo ""
    return

// 削除ボタンの処理
*OnButtonDel
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // ピン止めの処理
        DelMemo memo.cnt
        break
    loop
    return

// ピン止めボタンの処理
*OnButtonPin
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // ピン止めの処理
        Pin memo.cnt
        break
    loop
    return

// 画面リサイズ時＋初期化表示
*OnResize
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // リサイズ時の処理
        Resize memo.cnt
        break
    loop
    return

// 画面リサイズ用の動き
*OnWidthChange
    n = HTCAPTION
    foreach memo
        // アクティブウィンドウを探す
        if(ginfo(2) != getWid(memo.cnt)){
            continue
        }

        // リサイズ用の処理
        n = WidthChange(memo.cnt)
        break
    loop
    return n
#global
